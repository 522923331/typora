# 总结

InnoDB存储引擎的索引是一颗B+树，完整的用户记录都存储在B+树第0层的叶子节点；其它层次的节点都属于内节点，内节点中存储的是目录项记录。即所有的用户记录都存储在B+树的叶子节点，所有的目录项记录都存储在内节点。

InnoDB的索引分为两种：

* 聚簇索引：以主键值的大小作为页和记录的排序规则，在叶子节点处存储的记录包含了表中所有的列
* 二级索引：以索引列的大小作为页和记录的排序规则，在叶子节点处存储的记录内容是索引列+主键

InnoDB存储引擎的B+树根节点自创建之日起就不能再被更改。

在二级索引的B+树内节点中，目录项记录由索引值、主键值和页号组成。

一个数据页至少可以容纳2条记录。

MYISAM存储引擎的数据和索引是分开存储的，这种存储引擎的索引全部都是二级索引，在叶子节点处存储的是列+行号（对于定长记录格式来说，如果是动态长度格式，存的是数据在内存中的偏移量。）



# 索引

由于很久没有看过，简单回顾一下：

Innodb数据页由7个部分组成，各个数据页可以组成一个双向链表，每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表。每个数据页都会给为存储在它里面的记录生成一个页目录，在通过主键查找某条记录的时候，可以在页目录中使用二分查找法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。

## 页分裂

下一个数据页用户记录的主键值必须大于上一个页中用户记录的主键值，这个过程称为页分裂。

为了使查询速度更快，每页数据都会设置一个页目录，页目录其实是一个数组，数组里面存储的是**槽点**

而一张表中的数据往往非常多，需要用到很多数据页来存储这些记录，那么为了使查询数据更快，就会编制一个目录，每个页对应一个 **目录项**，每个目录项包括以下两个部分：

* 页的用户记录中最小的主键值，用key来表示
* 页号，用page_no来表示

上面的目录就是**索引**

目录项记录（也即索引）也是通过数据页来存储的，通过record_type来区分：

* 0：普通的用户记录
* 1：目录项记录
* 2：Infimum记录
* 3：Supremum记录

## B+树索引

树图大概如下：

![截屏2022-11-08 下午12.11.49](/Users/sh00050ml/Library/Application Support/typora-user-images/截屏2022-11-08 下午12.11.49.png)

页与页之间是双向链表，页内是槽点单向链表，记录与记录之间是单向链表。

B+树中的**每层节点**都按照索引列的值从小到大的顺序排序组成了双向链表。

### 聚簇索引

聚簇索引满足以下两个特点：

* 使用记录主键值的大小进行记录和页的排序，这包括三方面的含义：
  * 页（包括叶子节点和内节点）内的记录按照主键的大小顺序排成一个单向链表，页内的记录被划分成若干个组，每个组中主键值最大的记录在页内的偏移量会被当作槽依次存放在页目录中，我们可以在页目录中通过二分法快速定位到主键列等于某个值的记录。
  * 各个存放用户记录的页也是根据页中用户记录的主键值大小顺序排成一个双向链表。
  * 存放目录项记录的页分为不同层级，在同一层级中的页也是根据页中目录项记录的主键值大小顺序排成一个双向链表，
* B+树的叶子节点存储的是完整的用户记录（包括隐藏列）。

我们把具有这两个特点的B+树称为聚簇索引。在InnoDB存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子结点），也就是所谓的 “数据即索引，索引即数据”。

### 二级索引

聚簇索引只能在搜索条件是主键时才能发挥作用，如果以别的列作为搜索条件呢？

可以根据这个被搜索的字段（这里定义为C2）来另建一个B+树。

这种以非主键列的大小为排序规则而建立的B+树需要执行回表操作才可以定位到完整的用户记录的索引方式，称为二级索引或辅助索引。

二级索引与聚簇索引的区别就是：

1. 聚簇索引是按照主键值的大小进行记录和页排序的，而二级索引是根据C2列的值大小进行记录和页排序的
2. B+树的叶子节点存储的不再是完整的用户记录，而是C2列+主键这两个列的值。
3. 当然，目录项记录中也不再是主键+页号的搭配，而是C2列+页号的搭配。

### 回表

通过c2=4查找到满足条件的叶子节点的主键值，然后再通过主键值到聚簇索引中重新定位完整的用户记录的过程就叫做回表。

如果C2列没有唯一性约束，也就是说c2=4可能有多个值，那么执行流程为：

1. 先从C2的B+索引树查找主键值，然后再进行回表操作（通过找到的主键重新定位完整用户数据）；

2. 继续从C2的B+树的叶子节点（因为上面已经定位到第一个c2=4的数据位置了，就不用再从树顶遍历了）中沿着记录组成的单向链表向后查找看是否还有满足c2=4的数据，如果有，重复1的操作

### 联合索引

也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引。比如 让B+树按照C2、C3列的大小进行排序，这里面包含两层含义：

1. 先把各个记录和页按照C2列进行排序
2. 在记录的C2**列相同**的情况下，再采用C3列进行排序
3. C3列也相同，那就按照主键列进行排序

此时叶子节点处的用户记录由C2列、C3列和主键列组成。

这种以C2列、C3列的大小为排序规则建立的B+树称为联合索引，也称为复合索引或多列索引。它本质上也是一个二级索引。

## InnoDB中B+树索引的注意事项

### 1.根节点万年不动窝

B+树的形成过程：

* 每当为某个表创建一个B+树索引（聚簇索引不是认为创建的，它默认就存在）时，都会为这个索引创建一个根节点页面。最开始表中没有数据的时候，每个B+树索引对应的根节点中既没有用户记录，也没有目录项记录。
* 随后向表中插入用户记录时，先把用户记录存储到这个根节点中
* 在根节点的可用空间用完时继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页（比如页a中），然后对这个新页进行页分裂操作，得到另一个新页（比如页b），这时新插入的记录会根据键值（聚簇索引中的主键值或者二级索引中对应索引列的值）的大小分配到页a或页b中，根节点此时便升级为存储目录项记录的页，也就是存储的是页a和页b对应的目录项记录。

根节点自创建之日起就不会再更改，这样才能在InnoDB引擎需要用到这个索引时，去那个固定的地方取出根节点的页号，从而可以访问这个索引。

### 2.内节点中目录项记录的唯一性

上面我们说目录项内包括两部分：主键值和页号，这个其实是针对聚簇索引说的，

那么当换成二级索引后，情况就变得不一样了，拿C2列来说，C2列的数据可能都是一样的，这样如果目录项中只是索引列值和页号，当一个新的数据进来后，如果有多个页数据，引擎就没有办法判断应该把数据放到哪一页（图6-16）。所以二级索引的内节点的目录项记录，实际上是由三部分组成：

* 索引列的值
* 主键值
* 页号

这样就能保证目录项的唯一性了，当数据进来时，就可以先比对C2列，相同就比对主键列（图6-17），然后就能找到该存放的数据页了。

![截屏2022-11-08 下午3.01.02](/Users/sh00050ml/Library/Application Support/typora-user-images/截屏2022-11-08 下午3.01.02.png)

#### tips：

由上可知，对于二级索引来说，数据先按照二级索引列的值进行排序，在二级索引列值相同的情况下，再按照主键值进行排序。所以，为C2建立索引其实相当于为（C2,C1【主键列】）列建立了一个联合索引。

唯一二级索引 由于可能存在多个null值，而且与MVCC服务也有关系，所以它的内节点的目录项记录也会包含记录的主键值。

### 3.一个页面至少容纳两条记录

B+树查询数据快的原理就是通过层级过滤，每个层级都能筛选掉许多无用的目录。如果一个大目录中装一个小目录，那么筛选效果就不存在了。所以InnoDB的一个数据也至少可以存放2条记录

## MYISAM中索引方案简介

上面讲到的都是InnoDB存储引擎的索引方案。

MYISAM 索引和数据分开存储，“索引是索引，数据是数据”。

MYISAM的索引方案虽然也是使用树形结构，但是却将索引和数据分开存储。

* 将表中的记录按照记录的**插入顺序**单独存储在一个文件夹中（称之为数据文件）。由于插入数据时没有按照主键大小排序，所以不能使用二分查找法。
  <img src="/Users/sh00050ml/Library/Application Support/typora-user-images/截屏2022-11-08 下午4.48.19.png" alt="截屏2022-11-08 下午4.48.19" style="zoom:33%;" />
* 使用MYISAM存储引擎的表会把索引信息单独存储到另外一个文件中（称为索引文件）。MYISAM会为表的主键单独创建一个索引，索引的叶子节点存储的不是完整的用户记录，而是主键值+行号。也就是通过索引找行号，通过行号找记录。从这里可以看出，MYISAM中建立的索引相当于全部都是二级索引。
* 其它列索引和联合索引也与InnoDB相似，只不过叶子节点处存储的是相应的列+行号。这些索引也全部都是二级索引。

mYISAM的回表操作是十分快速的，因为它是拿着地址偏移量直接到文件中取数据。而InnoDB是通过获取主键之后再去聚簇索引中找记录，虽然说也不慢，但还是比不上直接用地址去访问。

# 创建和删除索引

CREATE TABLE 表名{

​	各个列的信息...,

​	(KEY|INDEX) 索引名（需要被索引的列）

}

key和index是同义词，任选一个用就行了。eg:

```sql
create table index_demo{
	c1 int,
	c2 int,
	c3 char(1),
	primary key (c1),
	index idx_c2_c3(c2,c3)
};
```

s或者通过修改表结构来添加删除索引：

ALTER TABLE 表名 ADD (KEY | INDEX) 索引名（需要被索引的列）

ALTER TABLE 表名 DROP (KEY | INDEX) 索引名;

