# 解决并发事务带来问题的两种基本方式

事务在并发执行时可能引发一致性问题的各种现象，大致可以划分为3种：

* 读-读：并发事务相继读取记录，允许同时发生
* 写-写：并发记录相继对相同的记录进行改动
* 读-写或写-读：一读一写事务

## 写-写情况

拿写写来说，这个时候就需要对记录加锁，该锁在内存中的结构，核心参数为：trx信息和is_waiting状态。

每个写事务都会在修改数据前，生成一个锁结构与记录关联，然后is_waiting = false，就可以操作修改数据了，否则，事务线程就会进入休眠状态，直到被上个线程将锁属性is_waiting 设置为 false并唤醒。

## 写-读或读-写情况

我们知道在读写或者写读的情况下，会出现脏读、不可重复读和幻读现象。

mysql在REPEATABLE READ隔离级别下很大程度的避免了幻读（意思是在某些情况下其实还是可能出现幻读现象的，举例：

```sql
#事务T1使用REPEATABLE READ隔离级别的事务
BEGIN;
#此时表中并没有id=30的数据
select * from hero where id = 30; #得到的是空集合
#此时事务T2执行了：insert into hero values(30,'关羽','魏');并提交
#接着T1就开始更新id=30的数据
update hero set country = '蜀' where id = 30;
#然后再执行查询
select * from hero where id = 30; #得到了一条数据：30,关羽,蜀
```

原因就是，ReadView并不能阻止T1执行update或者delete语句来改动这个新插入的记录（由于T2已经提交，改动记录并不会造成阻塞），但是这样一来，这条新记录的trx_id隐藏列的值就变成了T1的事务id。之后T1再使用普通的select语句去查询这条记录时，就可以看到这条记录了。因为这个特殊现象的存在，我们也可以认为InnoDB中的MVCC并不能完全禁止幻读。

）。

怎么避免脏读、不可重复读和幻读现象呢？有两种可选的方案：

* 方案1：读操作使用多版本并发控制（MVCC），写操作进行加锁

  写操作针对的是最新版本的记录，读操作读的是记录的快照版本，记录的历史版本和最新版本两者并不冲突，也就是使用MVCC时，读-写操作并不冲突

* 方案2：读、写都采用加锁的方式

  一些不允许读取记录的旧版本的情况，比如在银行存款事务中，需要先读取余额，然后加上存款额，最后写到数据库中。这个过程中，不想让别的事务再访问余额，直到事务完成。这样在读取记录时，也需要加锁。也就意味着读操作和写操作也得像写-写操作那样排队执行。

很明显，如果采用MVCC方式，读-写操作彼此并不冲突，性能更高；如果采用加锁方式，读-写操作彼此需要排队执行，从而影响性能。但是某些特殊场景又不得不考虑加锁方式。

### 一致性读

事务利用MVCC进行读取操作称为一致性读（Consistent Read）,或者一致性无锁读（又称快照读）。

### 锁定读

我们把在读取记录前就为该记录加锁的读取方式称为锁定读（Locking Read）。

#### 共享锁和独占锁

并发事务的读-读操作并不会引起什么问题，但写-写、读-写或写-读可能会引起并发问题，需要使用MVCC或者加锁的方式来解决它们。对于加锁的方式，mysql给锁分类如下：

* 共享锁（Shared Lock）：简称S锁，在事务读取一条记录时，需要先获取该记录的S锁。
* 独占锁（Exclusive Lock）：也称排它锁，简称X锁，在事务要改动一条记录时，需要先获取该记录的X锁。

S锁和X锁的兼容关系如下：

| 兼容性 |  X锁   |  S锁   |
| :----: | :----: | :----: |
|  X锁   | 不兼容 | 不兼容 |
|  S锁   | 不兼容 |  兼容  |

#### 锁定读的的语句：

格式：

对读记录加S锁：select ... lock in share mode;

对读记录加X锁：select ... for update;

### 写操作

写操作无非delete、update、insert这3种。

* DELETE：“先定位待删除记录在B+树的位置，然后获取这条记录的X锁”（的过程就是获取X锁的锁定读），最后再执行delete mark操作。
* UPDATE：update又分为3种：
  * 未修改记录的键值并且被更新列占用存储空间大小不变：“先在B+树中定位到这条记录的位置，然后获取这条记录的X锁”（的过程就是获取X锁的锁定读），最后在原记录的位置进行修改操作
  * 未修改记录的键值并且被更新列占用存储空间发生变化：“先在B+树中定位到这条记录的位置，然后获取这条记录的X锁”（的过程就是获取X锁的锁定读），之后将该记录彻底删除掉，最后再插入一条新记录。
  * 修改了记录的键值：相当于在原记录上执行delete操作后，再insert一条记录，加锁操作需要按照DELETE和INSERT的规则进行。
* INSERT：一般情况下，新插入记录受隐式锁保护，不需要在内存中为其生成对应的锁结构。

# 多粒度锁

上面说到的锁都是行级锁或者行锁，影响的也就是一条记录而已。

其实一个事务也可以在表级别进行加锁，称为表级锁或表锁。

表锁也分为S锁和X锁，原理与行锁一样，会影响表中的所有记录。

那当想加表锁的时候，怎么知道有没有行记录加锁呢？遍历行的话，效率就太低了。

于是就有了意向锁（Intention Lock），所谓意向锁，就是有这个意向。

* 意向共享锁（Intention Shared Lock）：简称IS锁，当事务准备在某条记录上加S锁时，需要先在表级别加一个IS锁
* 意向独占锁（Intention Exclusive Lock）：简称IX锁，当事务准备在某条记录上加X锁时，需要先在表级别加一个IX锁

总结一下：IS锁、IX锁是表级锁，它们的提出仅仅是为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，以避免用遍历的方式来查看表中有没有上锁的记录（每当加行S锁或X锁时，如果对应的意向锁不存在的话，就会先加对应的IS锁或IX锁）；也就是说IS锁与IX锁以及IX锁与IX锁直接都是相互兼容的。



# mysql中的行锁和表锁

对于MyISAM、MEMORY、MERGE这些存储引擎来说，它们只支持表级锁，而且这些存储引擎并不支持事务。

## InnoDB存储引擎中的锁

* 表锁，表锁可以分为以下几种：
  * 表级别的S锁、X锁：InnoDB的表级锁相当鸡肋，使用场景有限，无需多关注。
  * server层的元数据锁（MetaData Lock，MDL）：在对某表执行DDL时，其它事务对该表执行DML会阻塞；同样，在堆该表执行DML时，其它事务对该表执行DDL也会阻塞住。这个阻塞过程就是通过MDL来实现的。
  * 表级别的意向锁（IS锁、IX锁）：意向锁的使命只是为了后续在加表级别的S锁或X锁时，判断表中是否有已经被加锁的记录，以避免用遍历的方式来查看表中有没有上锁的记录。（每当加行S锁或X锁时，如果对应的意向锁不存在的话，就会先加对应的IS锁或IX锁）
  * 表级别的AUTO-INC锁：系统自动给AUTO-INCREMENT修饰的列进行递增赋值时，可能会用到
* 行锁，行锁又可以细分为以下几种：
  * Record Lock（记录锁）：锁定当前记录的锁
  * Gap Lock（间隙锁）：RR隔离级别下，通过间隙锁来解决幻读问题。
  * Next-Key Lock（next-key锁）：本质上等于 记录锁+间隙锁，它既能保护该条记录，又能阻止别的事务将新记录插入到被保护记录前面的间隙中
  * Insert Intention Lock（插入意向锁）：如果插入的位置已经被别的事务加了Gap 锁（或者 next-key 锁），此时就会在该位置添加一个Insert Intention Lock（插入意向锁），表明想在某个间隙中插入新记录。插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁（就是这么鸡肋）。
  * 隐式锁：不显式的加锁，如果别的事务在执行过程中不需要获取与该隐式锁相冲突的锁，就可以避免在内存中生成锁结构。如果有冲突，就会创建一个行级X锁。

# 死锁

| 发生时间编号 |                            T1                            |                              T2                              |
| :----------: | :------------------------------------------------------: | :----------------------------------------------------------: |
|      1       |                          BEGIN;                          |                                                              |
|      2       |                                                          |                            BEGIN;                            |
|      3       |         select * from hero where id=1 for update         |                                                              |
|      4       |                                                          |           select * from hero where id=3 for update           |
|      5       | select * from hero where id=3 for update<br />此操作阻塞 |                                                              |
|      6       |                                                          | select * from hero where id=1 for update<br />死锁发生，记录日志，服务器回滚一个事务 |

简单分析：

* 从3中可以看出，T1先对id=1的聚簇索引记录加了个 X记录锁
* 从4中可以看出，T2先对id=3的聚簇索引记录加了个 X记录锁
* 从5中可以看出，T1接着也想对id=3的聚簇索引记录加 X记录锁，但是与4中T2持有的锁冲突，所以T1进入阻塞状态，等待获取锁
* 从6中可以看出，T2接着也想对id=1的聚簇索引记录加 X记录锁，但是与3中T1持有的锁冲突，所以T2进入阻塞状态，等待获取锁

由于T1和T2都在等待对方先释放掉与自己需要的锁相冲突的锁，导致T1和T2都不能继续执行，于是发生了死锁。

那么可以通过 show engine InnoDB status 语句来获取当前系统中各个系统中的加锁情况，show engine InnoDB status 只会显示最近一次发生的死锁信息，如果死锁频繁出现，可以将全局变量Innodb_print_all_deadlocks设置为ON，可以记录所有的死锁信息。



InnoDB有一个死锁检测机制，当检测到死锁发生时，会选择一个较小的事务进行回滚（所谓较小的事务，是指在事务执行过程中插入、更新或删除的记录条数较少的事务）。

我们可以通过优化语句来改变加锁顺序，或者建立合适的索引以改变加锁过程，从而避免死锁问题。



# 查看事务加锁情况

```sql
select * from information_schema.INNODB_TRX\G;
```

INNODB_TRX：该表存储了InnoDB存储引擎当前正在执行的事务信息，包括事务id（没有事务的话，就是该事务对应的内存结构的指针），事务状态等。

```sql
trx id: 46611 #事务id
trx_state : RUNNING #运行状态：正在运行
trx_started: 2020-05-07 18:20 : 34 
trx_requested_lock_id: NU1ι 
trx_wait_started: NULL 
trx_weight: 2 
trx_mysql_thread_id: 2 
trx_query : NULL 
trx_operation_state: NULL 
trx_tables_in_use: 0 
trx_tables_locked: 1 #目前加了几个表级锁
trx_lock_structs: 2 #该事务生成了几个内存中的锁结构
trx_lock_memory_bytes: 1160 
trx_rows_1ocked: 1  #目前加了几个行级锁
trx_rows_modified: 0 
trx_concurrency_tickets : 0 
trx_isolatioo_level: REPEATABLE READ #隔离级别
trx_unique_checks: 1 
trx_foreign_key_checks: 1 
trx_last_foreign_key_error: NULL 
trx_adaptive_hash_latched : 0 
trx_adaptive_hash_timeout: 0 
trx_is_read_only: 0 
trx_autocommit_non_locking: 0
```

INNODB_LOCKS：该表记录了一些锁信息，主要包括下面两个方面的锁信息：

* 如果一个事务想要获取某个锁但未获取到，则记录该锁信息
* 如果一个事务获取到了某个锁，但是这个锁阻塞了别的事务，则记录该锁信息

也就是说，只有当系统中发生了某个事务因为获取不到锁而阻塞的情况时，该表中才会有记录。

INNODB_LOCK_WAITS：该表记录每个阻塞事务是因为获取不到哪个事务持有的锁而阻塞。

* requesting_trx_id：获取不到锁而被阻塞的事务的事务id
* blocking_trx_id：获取到别的事务需要的锁导致其被阻塞的事务的事务id。

INNODB_LOCKS 和 INNODB_LOCK_WAITS在mysql8.0就被删除了。

那么可以通过 show engine InnoDB status 语句来获取当前系统中各个系统中的加锁情况。

如果想看出到底是哪个事务对哪些记录加了锁，将系统变量innodb_status_output_locks设置为ON,再运行一次就好了。

注意：

* 如果某个事务没被分配唯一的事务id，则执行show engine InnoDB status语句时并不会显示该事务在执行过程中持有的锁
* show engine InnoDB status不显示隐式锁

# 总结

MVCC和加锁是解决并发事务带来一致性问题的两种方式。

事务利用MVCC进行的读取操作称为一致性读，在读取记录前加锁的读取操作称为锁定读。

锁定读语法：

* select ... lock in share mode
* Select ... for update

Insert 语句一般情况下不需要在内存中生成锁结构，并单纯依靠隐式锁保护插入的记录。update和delete语句在执行过程中，在B+树中定位到待改动记录并给该记录加锁的过程也算是一个锁定读。

IS、IX锁是表级意向锁，它们的提出仅仅是为了在之后加表级别的S锁和X锁时，可以快速判断表中的记录是否被上锁，以免用遍历的方式去判断。

InnoDB的行级锁类型：

* Record Lock：记录锁，只对记录本身加锁
* Gap Lock：间隙锁，锁住记录的间隙，防止别的事务向该间隙插入新记录，解决了幻读问题。
* Next-Key Lock：Record Lock 和Gap Lock的结合体，既保护记录本身，也防止别的事务向该间隙插入新记录。
* Insert Intention Lock：插入意向锁，鸡肋的锁，仅仅是为了解决”在当前事务插入记录时因碰到别的事务加的Gap锁而进入等待状态时，也生成一个锁结构“而提出的。该锁不会阻止别的事务继续获取该记录上任何类型的锁。
* 隐式锁：依靠记录的trx_id属性来保护不被别的事务改动该记录

InnoDB存储引擎的锁都在内存中对应着一个锁结构。有时为了节省锁结构，会把符合下面条件的锁放到同一个锁结构中：

* 在同一个事务进行加锁操作
* 被加锁的记录在同一个页面中
* 加锁的类型是一样的
* 等待状态是一样的

不同事务由于互相持有对方需要的锁而导致事务都无法继续执行的情况称为死锁。死锁发生时，InnoDB会选择较小的事务进行回滚，可以通过查看死锁日志来分析死锁发生的过程。
