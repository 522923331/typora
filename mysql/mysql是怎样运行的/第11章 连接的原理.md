# 前菜：

单表查询就是基于上一章说的几种查询方法来执行查询的。这里简单定义两个表查询的逻辑：

t1表：

| M1   | N1   |
| ---- | ---- |
| 1    | a    |
| 2    | b    |
| 3    | c    |

t2表：

| M2   | N2   |
| ---- | ---- |
| 2    | b    |
| 3    | c    |
| 4    | d    |

最简单的一种连接查询（内连接）语句：select * from t1,t2;这种查询会产生笛卡尔积，查询的结果条数为3*3=9

我们把第一个被查询的表称为驱动表，第二个及之后被查询的表称为被驱动表。

Sql1：select * from t1,t2 where t1.m1 > 1 and t1.m1=t2.m2 and  t2.n2 < 'd';

从驱动表中每获取到一条记录，都需要到被驱动表中查找匹配的记录。

也就是说上面的连接查询中，共需要查询1次t1表，2次t2表。如果把t1.m1>1去掉，那么就需要查询1次t1表，3次t2表。

注意：并不是把所有满足条件的驱动表记录先查询出来放到一个地方，然后再去被驱动表中查询的（比如驱动表查询到的数据量非常大），而是每获得一条驱动表记录，就立即到被驱动表中寻找匹配的记录。

## 内连接和外连接

场景：有学生表和分数表，现在需要查询所有学生的考试成绩，如果使用上面的内连接的形式，那么没有考试分数的人将不能被查询出来。此时就需要用到外连接来处理。	内外连接定义如下：

* 对于内连接的两个表，若驱动表中的记录在被驱动表中找不到匹配的记录，则该记录不会加入到最后的结果集。前面提到的连接都是内连接。
* 对于外连接的两个表，即使驱动表中的记录在被驱动表中没有匹配的记录，也仍然会加入到最后的结果集。

在mysql中，根据选取的驱动表的不同，外连接可细分为两种：

* 左（外）连接：选取左侧的表为驱动表。
* 右（外）连接：选取右侧的表为驱动表。

可仍有问题：即对于外连接来说，有些时候我们也不想把驱动表的全部记录都加入到结果集中。有时需要，有时不需要。

解决办法就是把过滤条件也分为两种，所以过滤条件在不同的地方是有不同的语义的。

* where子句中的过滤条件
  where子句中的过滤条件就是平时最常见的那种。不论是内连接还是外连接，凡是不符合where子句中过滤条件的记录都不会被加入到最后的结果集中。
* on子句中的过滤条件
  on子句的过滤条件会把所有驱动表中的记录都加入到结果集中，如果被驱动表中找不到对应的记录，则用null填充。

注意：在内连接中，where子句和on子句是等价的，所以内连接不要求强制写明on子句。

### 内连接的语法

mysql中针对内连接提供了好多不同的语法:

Select * from t1[inner | cross] join t2 [on 连接条件] [where 普通过滤条件];

下面4种写法都是等价的：

Select * from t1join t2;

Select * from t1inner join t2;

Select * from t1cross join t2;

Select * from t1, t2;

由于内连接会把不符合on子句或者where子句条件的记录都过滤掉，所以驱动表和被驱动表是可以互换的，不会影响最后的查询结果。

### 左（外）连接的语法

Select * from t1 left [outer] join t2 on 连接条件 [ where 普通过滤条件]；

其中[]里面的可以省略。此时我们把放在左边的表称为外表或者驱动表，放在右边的表称为内表或者被驱动表。

### 右（外）连接语法

Select * from t1 right [outer] join t2 on 连接条件 [ where 普通过滤条件]；

在右外连接中，右边的表称为外表或者驱动表，左边的表称为内表或者被驱动表。

# 连接的原理

## 嵌套循环连接

对于“驱动表只访问一次，但被驱动表却可能访问多次，且访问次数取决于对驱动表执行单表查询后的结果集中有多少条记录”的连接执行方式，称为嵌套循环连接（Nested-Loop Join）。 这是最简单也是最笨拙的一种连接查询算法。

再次强调：每获得一条驱动表记录，就会立即到被驱动表中寻找匹配的记录，并没有将驱动表的记录进行任何缓存，然后将符合条件的记录返回给客户端。

那么如果有3个表连接，就会将前两个表得到的结果集（抽象概念，实际上并没有缓存到内存和磁盘中，而是直接再次去被驱动表中查询）看作为新的驱动表，第三张表作为被驱动表。

用伪代码来表示这个过程如下：

```java
for each row in t1 satisfying conditions about t1{
  for each row in t2 satisfying conditions about t2{
  	for each row in t3 satisfying conditions about t3{
  		send to client;
		}
	}
}
```

## 使用索引加快连接速度

在嵌套循环连接中，可能要访问多次被驱动表，如果被驱动表是全表扫描，那么效率就会比较低，那么我们就可以通过利用索引来加快查询速度。

就拿Sql1：select * from t1,t2 where t1.m1 > 1 and t1.m1=t2.m2 and  t2.n2 < 'd';来说：

单表的访问方法在第10章已经说过了，这里特别说一下被驱动表的使用索引的情况。

根据上面的sql可以看到，原来的t1.m1 =t2.m2 这个涉及两个表的过滤条件在针对t2表进行查询时，关于t1表的条件就已经确定了，我们只需要单单优化针对t2表的查询即可（实际上两个表的查询都是要考虑最佳性能的）。

可以进行如下尝试：

* 在m2列上建立索引。因为针对m2列的条件是等值查找，所以可能使用到ref访问方法，然后再回表后判断t2.n2 < 'd'这个条件是否成立。如果没m2列是表的主键或者是不允许为null的唯一二级索引，那么代价就是常数级别的了。 在单表查询中我们称之为const，在连接查询中，对被驱动表进行等值查询的访问方法被称之为eq_ref。
* 在n2列上建立索引。可能用到的是range访问方法，然后再回表判断包含m2列的条件是否成立。如果m2列和n2列都存在索引，那么就会从中挑一个代价最低的索引来查询t2表。

另外，连接查询的查询列表和过滤条件中可能只涉及被驱动表的部分列，而这些列刚好都是某个二级索引的一部分，在这种情况下，即便不能使用eq_ref,ref,ref_or_null或者range等访问方法来查询被驱动表，也可以通过扫描全部二级索引记录（即使用index访问方法）来查询被驱动表。所以建议不要使用 * 作为查询列表，而是把真正使用到的列作为查询列表。

## 基于块的嵌套循环连接

这个是对嵌套循环连接的一个优化吧。就是说，如果对于驱动表结果集中的每一条记录，都要对被驱动表进行全表扫描，但是表数据有可能很大，在记录对比的时候，需要把磁盘的数据加载到内存，由于磁盘数据量很大，需要反复加载到内存才能验证驱动表结果集中的一条数据，那么整个过程的I/O的代价将是及其大的。

由此引出了Join Buffer（连接缓冲区）的概念。Join Buffer就是在执行查询前，为驱动表结果集申请的一块固定大小的内存。默认大小是262144字节（也就是256KB），最小可设置为128字节。可以通过启动选项或者系统变量join_buffer_size进行配置。

这样就可以让每一条被驱动表的记录一次性的与Join Buffer中的多条驱动表记录进行匹配。这样可以显著的减少被驱动表I/O的代价。

另外，Join Buffer中只会存放查询列表中的列和过滤条件中的列，所以这也再次提醒我们，最好不要把 * 作为查询列表，这样Join Buffer就可以放置更多的记录。

# 总结

从本质上来说，连接就是把各个表中的记录都取出来依次进行匹配，并把匹配后的组合发给客户端。如果不加任何过滤条件，产生的结果就是笛卡尔积。

在mysql中，连接分为

* 内连接：若驱动表中的记录在被驱动表中找不到匹配的记录，则该记录不会加入到最后的结果集。
* 外连接：即使驱动表中的记录在被驱动表中没有匹配的记录，也仍然会加入到最后的结果集。
  * 左（外）连接：把放在左边的表称为外表或者驱动表，放在右边的表称为内表或者被驱动表。
  * 右（外）连接：把右边的表称为外表或者驱动表，左边的表称为内表或者被驱动表。

连接原理：

* 嵌套循环连接：驱动表只访问一次，但被驱动表却可能访问多次，且访问次数取决于对驱动表执行单表查询后的结果集中有多少条记录，也是最简单最笨拙的一种连接查询算法。
* 使用索引加快连接速度：对表添加索引，进而减少索引记录，提高查询效率。
  * 注意：建议不要使用 * 作为查询列表，而是要使用真正的列作为查询列表，因为连接查询的查询列表和过滤条件中可能只涉及被驱动表的部分列，而这些列刚好都是某个二级索引的一部分，在这种情况下，最差也可以通过index访问方法来查询被驱动表。
* 基于块的嵌套循环连接：嵌套循环连接的优化版本。引入了Join Buffer（连接缓冲区）的概念，将驱动表查询到的结果集先放到Join Buffer中，这样就可以让每一条被驱动表的记录一次性的与Join Buffer中的多条驱动表记录进行匹配。这样可以显著的减少被驱动表I/O的代价。
  * 注意：Join Buffer中只会存放查询列表中的列和过滤条件中的列，所以这也再次提醒我们，最好不要把 * 作为查询列表，这样Join Buffer就可以放置更多的记录。
