# 总结

mysql会对用户编写的查询语句执行一些重写操作，比如：

* 移除不必要的括号，如：
  Select * from (t1,(t2,t3)) where t1.a=t2.a and t2.b=t3.b;优化器会把语句中不必要的括号移除掉：
  Select * from t1,t2,t3 where t1.a=t2.a and t2.b=t3.b;

* 常量传递
  比如表达式a=5 and b > a；当使用and操作符将这个表达式和其它涉及列a的表达式连接起来时，可以将其它表达式中a的值替换为5：a=5 and b > 5;  如果是or操作符则不行。

* 移除没用的条件
  对于一些明显永远为true或者false的表达式，优化器会将它们移除掉。如：（a <1 and b =  b）or (a =6 or 5 !=5)，简化后为：
  （a <1 and true）or (a =6 or false),继续简化为：a <1 or a = 6。

* 表达式计算
  如果某个列以单独的形式作为表达式的操作数，并且表达式中只包含常量的话，它的值会被先计算出来，比如：a=5+1会被简化为a=6;如果是 abs(a) >5 或者 -a <-8 则不会被简化，因为该列不是以单独的形式出现的。

* having子句和where子句的合并
  如果查询语句中没有出现诸如 sum,max 这样的聚集函数以及group by子句，查询优化器就会把having子句和where子句合并起来。

* 常量表检测
  mysql认为下面两种类型的查询运行得特别快：

  * 类型1：查询表中只有一条记录，或者一条记录都没有
  * 类型2：使用主键或者唯一二级索引列等值匹配作为搜索条件来查询某个表。

  把通过以上两种方式查询的表称为常量表。查询优化器会把查询条件中设计改表的条件全部替换成常数，最后再分析其余表的查询成本。

## 空值拒绝

空值拒绝：在外连接查询中，指定的where子句中包含被驱动表中的列不为null值的条件称为空值拒绝（reject-null）。

在被驱动表的where子句符合空值拒绝的条件时，外连接和内连接可以相互转换。

## 子查询的分类

子查询可以按照不同维度进行不同的分类，比如按照子查询返回的结果集分类：

* 标量子查询：只返回一个单一值的子查询。如：select (select m1 from t1 limit 1) 或者 select * from t1 where m1 = (select min(m2) from t2 ) 
* 行子查询：返回一条记录的子查询（包含多列，如果是一列那就是标量子查询了）。如：
  select * from t1 where (m1,n1) = (select m2,n2 from t2 limit 1); m1和n1列分别等于子查询结果中的m2和n2列。
* 列子查询：查询出一列的数据（这一列需要包含多条记录，如果是一条就是标量子查询了）。
  如：select * from t1 where m1 in (select m2 from t2)
* 表子查询：就是子查询的结果即包含很多条记录，又包含很多个列。
  如：select * from t1 where (m1,n1) in (select m2,n2 from t2 )
  表子查询和行子查询的区别就是是否使用了 limit 1

按照与外层查询的关系来分类：

* 不相关子查询：子查询可以单独运行出结果。
* 相关子查询：子查询的执行需要依赖于外层查询的值。如：select * from t1 where m1 in (select m2 from t2 where n1 = n2)



## 子查询语法注意事项：

* 子查询必须用小括号括起来，不用则非法，如：select select m1 from t1; 非法
* 在select子句中的子查询必须是标量子查询，如果子查询结果集中有多个列或者多个行，非法，如：select (select m1,n1 from t1); 非法
* 要想得到标量子查询或者行子查询，但又不能保证子查询的结果集只有一条记录时，应该使用limit 1语句来限制记录数量
* 对于 [not] in/any/some/all 子查询来说，子查询中不允许有limit语句，如下是非法的：
  select * from t1 where m1 in (select * from t2 limit 2)
  为啥不合法？目前就是这么规定的，以后的版本可能会支持吧！

子查询的结果集相当于一个集合，集合里的值是否排序一点都不重要。比如下面这个sql的order by子句就有点画蛇添足：

select * from t1 where m1 in (select m2 from t2 order by m2)

正因为 [not] in/any/some/all子查询不支持 LIMIT语句，所以在子查询中使用 ORDER BY 子句、 DISTINCT子句以及没有聚集函数和 HAVING 子句的 GROUP BY 子句是毫无意义的。

## 物化（哈希索引使用场景，memory存储引擎）

Mysql 把 ”将子查询结果集中的记录保存到临时表的过程“ 称为物化，这个临时表被称为物化表。在将结果集写入临时表时，有两点注意事项：

* 该临时表的列就是子查询结果集中的列
* 写入临时表中的记录会被去重

物化表中的记录都建立了索引（基于内存的物化表有哈希索引，基于磁盘的物化表有B+树索引）

一般情况下，子查询结果集不会大得离谱，所以会为它建立基于内存的使用memory存储引擎的临时表，而且会为该表建立哈希索引。

mysql将in子查询进行了很多优化。如果in子查询符合转换为半连接的条件，查询优化器会优先把该子查询转换为半连接，然后再考虑下面5种执行半连接查询的策略中哪个成本最低，最后选择成本最低的执行策略来执行子查询。

* table pullout（子查询中的表上拉）
* Duplicate weedout（重复值消除）
* LooseScan（松散扫描）
* Semi-join Materialization（半连接物化）
* FirstMatch（首次匹配）

如果in子查询不符合转换为半连接的条件，查询优化器会从下面的两种策略中找出一种成本更低的方式执行子查询：

* 先将子查询物化，再执行查询
* 执行in到exists的转换

mysql在处理带有派生表的语句时，优先尝试把派生表和外层查询进行合并；如果不行，再把派生表物化掉，然后执行查询。	