只有在事务对表中的记录进行改动时，才会为这个事务分配一个唯一的事务id。

聚簇索引记录除了会保存完整的用户数据外，还会自动添加trx_id、roll_pointer两个隐藏列。如果表没有主键并且没有不为null的唯一索引列，还会自动添加row_id隐藏列。

删除一条记录的过程：

1. delete mark阶段：删除已执行但事务尚未提交阶段，记录还在正常链表中，只是将记录的delete_flag标识位设置为1。
2. purge阶段：事务提交后，会有专门的线程真正的执行删除。然后把该记录从正常链表中移除，并且加入到垃圾链表中。同时修改其它与之相关的数据。



Undo log保证了事务的原子性。

那些没有提交的事务写的redo日志可能也已经刷盘了，这时mysql会通过查询undo页面链表状态属性为active的，它意味着有一个活跃的事务正在向这个undo页面链表中写入undo日志，找对这个事务的id，然后执行回滚操作。

# 总结

Undo log保证了事务的原子性。undo log记载了回滚一个操作所需的必要内容。

在事务对表中的数据进行改动时，才会为这个事务分配一个唯一的事务id，事务id值是一个全局递增的数字。

在一个事务执行过程中，最多分配4个undo页面链表，分别是：

* 针对普通表的insert undo链表
* 针对普通表的update undo 链表
* 针对临时表的insert undo链表
* 针对临时表的update undo 链表

只有在真正用到这些链表的时候才会去创建它们。

一个undo页面链表可以被重用，需要符合下面两个条件：

* 该链表中只包含一个undo页面
* 该undo页面已经使用的空间小于整个页面空间的3/4

