# InnoDB的buffer pool

## 啥是buffer pool

为了缓存磁盘的页，mysql服务器启动时向操作系统申请一片连续的内存，这片内存就是buffer pool（缓冲池）。

默认大小为128MB，可以通过修改启动项innodb_buffer_pool_size来设置大小。

为了更好的管理缓冲页，每个缓冲页都会创建一些控制信息，每个缓冲页的控制信息占用的内存大小是相同的，并给它开辟了一块内存用来存储控制信息，叫做控制块。控制块与缓冲块一一对应。

## free链表的管理

free链表用来管理控制块，也就是用来管理缓冲页是否可用。

每当需要从磁盘中加载一个页到buffer pool中时，就从free链表中取出一个缓冲页对应的控制块。后续简化为缓冲页。

free链表的基节点主要由三部分组成：链表的头结点地址、尾结点地址，以及当前链表中节点的数量信息。基节点是另外单独分配的内存，占用40字节。

## 缓冲页的哈希处理

当我们需要使用一个缓冲页时，如何找到这个缓冲页呢？

通过哈希表：

key = 表空间号+页号 

value = 控制块的地址

先从哈希表根据key查询是否有对应的缓冲页，如果没有，就会从free链表中选一个空闲的缓冲页，然后将磁盘中对应的页加载到buffer pool中对应的缓冲页位置上。

## flush链表的管理

如果我们修改了buffer pool中某个缓冲页的数据，它就与磁盘上的不一致了，这样的缓冲页也称为脏页（dirty page）。

为了不影响程序的性能，mysql并不会每次都立马刷新到磁盘。

那么这些脏页对应的控制块，就被存储在一个新的链表中，就是flush链表。

## LRU链表的管理

### 简单的LRU链表

当buffer pool的内存被占用满时，当有新的页需要放到缓冲区时，就需要将老的缓冲页删除，使用的删除链表就是LRU链表，策略就是LRU（最近最少使用，Least Recently Used），链表运作方式：

* 如果该页不在buffer pool中，在把该页从磁盘加载到buffer pool中的缓冲页时，就把该缓冲页对应的控制块作为节点塞到LRU链表的头部
* 如果该页已经被加载到Buffer Pool中，则直接把该页对应的控制块移动到LRU链表的头部

这样，LRU链表尾部就是最紧最少使用的缓冲页了。

### 划分区域的LRU链表

简单的LRU链表在mysql中会有两种尴尬的情况：

* 情况1：InnoDB提供了预读（read ahead）服务，所谓预读，就是InnoDB认为执行当前请求时，可能会在后面读取某些页面，于是就预先将这些页面加载到buffer pool中。根据触发方式的不同，预读又可以分为以下两种：

  * 线性预读：如果顺序访问某个区的页面超过系统变量innodb_read_head_threshold（默认56）的值，就会触发一次异步读取下一个区中全部的页面到buffer pool中的请求。
  * 随机预读：如果某个区13个连续的页面都被加载到了buffer pool中，就会触发一次异步读取本区所有页面到buffer pool中的请求。默认值是OFF。

  预读本来是好事，但是如果预读的数据使用不到的话，就会导致处于LRU链表尾部的一些缓冲页会很快被淘汰掉，从而大大降低buffer pool命中率。

* 情况2：有的小伙伴可能会写一些需要进行全表扫描的语句（比如没建立合适的索引或者没有where子句的查询时）。

  全表扫描意味着将访问该表的聚簇索引的所有叶子节点对应的页，如果访问的页面很多，就会将其他语句在执行过程中用到的页面”排挤“出buffer pool

一言以蔽之，可能降低buffer pool命中率的两种情况：

* 加载到buffer pool中的页不一定被用到
* 如果有非常多的使用频率偏低的页被同时加载到buffer pool中，则可能会把那些使用频率非常高的页从buffer pool中淘汰掉。

于是，mysql根据上面的情况，将LRU链表按照一定比例分成两截：

* 一部分存储使用频率非常高的缓冲页；这一部分链表也称为热数据，或者称为young区域
* 另一部分存储使用频率不是很高的缓冲页；这一部分链表也称为冷数据，或者称为old区域

```sql
show variables like 'innodb_old_blocks_pct';
//结果
innodb_old_blocks_pct,37
```

默认情况下，old区域在LRU链表中所占的比例是37%，也就是说，old区域大约占LRU链表的3/8。

链表的前面是热数据，后面是冷数据。

这样，就可以针对上面提到的两种可能降低buffer pool命中率的情况进行优化了：

* 针对预读的页面可能不进行后续访问的优化

  当磁盘上的某个页面初次加载到buffer pool中的某个缓冲页时，改缓冲页对应的控制块会放到old区域的头部。不会影响young区域中使用比较频繁的缓冲页

* 针对全表扫描时，短时间内访问大量使用频率非常低的页面的优化

  在进行全表扫描时，被加载到old区域的数据，如果是根据是否使用这个条件，来判断是否将old区域的缓冲页放到young区域的话，在经过后续使用后，就会进入到young区域的头部，这样仍然会将那些使用频率高的页面给”排挤“出去。解决办法就是：根据时间间隔来作为判断依据。

  ```sql
  show variables like 'innodb_old_blocks_time';
  //结果
  innodb_old_blocks_time,1000
  ```

默认值是1000ms，也就是说第一次访问和最后一次访问的时间间隔超过1秒的缓冲页才会被加入到young区域。

### 更进一步优化LRU链表

这个的对于young区域来说的，由于young区域的缓冲页都是热点数据，如果每次访问都要修改LRU链表节点，过于频繁会大大降低使用性能，为了解决这个问题，就提出了一个优化策略，就是young区域1/4后面的缓冲页被访问时，才会被移动到LRU链表头部。在1/4内的缓冲页即便被访问也不会移动。这样就可以降低调整LRU链表的频率，从而提升性能。

## 刷新脏页到磁盘

后台有专门的线程每隔一段时间就会把脏页刷到磁盘。刷新方式有两种：

* 从LRU链表的冷数据中刷新一部分页面到磁盘

  后台线程会定时从LRU链表尾部开始扫描一些页面，扫描的页面数量可以通过系统变量innodb_lru_scan_depth来指定，如果发现是脏页，则把它们刷新到磁盘。这种刷新方式称为BUF_FLUSH_LRU。

* 从flush链表中刷新一部分页面到磁盘

  后台线程也会定时从flush链表中刷新一部分页面到磁盘，刷新的速度取决于当时系统是否繁忙。这种刷新页面的方式称为BUF_FLUSH_LIST。

如果后台线程刷新脏页的速度比较慢，导致用户在准备加载一个磁盘页到buffer pool中时没有可以用的缓冲页。这时会先尝试从LRU尾部释放掉未修改的缓冲页；如果释放失败，则不得不将脏页同步刷新到磁盘上（与磁盘交互是很慢的，这会降低处理用户请求的速度）。

## 多个buffer pool实例

多线程环境下，访问buffer pool中的各种链表都需要加锁处理，当并发访问量特别高时，单一的buffer pool可能会影响请求的处理速度。所以可以把1个buffer pool拆分成若干个小buffer pool，每个buffer pool都称为一个实例。当buffer pool的内存大于1G的时候，才能进行拆分，否则会拆分无效。

# 总结

磁盘太慢，用内存作为缓冲区很重要。

buffer pool本质上是InnoDB向操作系统申请的一段连续的内存空间。可以通过innodb_buffer_pool_size来调节它。

buffer pool主要由控制块+缓冲页[+碎片]组成。控制块和缓冲页是一一对应关系。如果有剩余空间不足以填充一组控制块和缓冲页，则会产生碎片。

InnoDB使用了很多链表来管理buffer pool：

* free链表：存储可以使用的空闲的缓冲页
* flush链表：用来存储脏页，脏页按照第一次被修改发生的时间顺序进行排序
* LRU链表：分为热数据（young区域）和冷数据（old区域）两部分，首次从磁盘加载到buffer pool中的页会放到old区域的头部，当访问时间间隔超过1s时，才会被加入到young区域。

buffer pool中的数据通过哈希表来管理。key为表空间号+页号，value为控制块的地址。

脏页：被修改的页。脏页不会被立即刷新，而是加入到flush链表中，待之后的某个时刻再刷新到磁盘。

刷新脏页的两种情况：

1. 后台线程定时扫描LRU链表尾部，发现脏页后会异步刷盘
2. 当buffer pool没有空闲的缓冲页，并且在释放LRU链表尾部的未被修改的缓冲页后，依然没有可用缓冲页时，就会同步刷新脏页到磁盘。

预读的两种情况：

1. 线性预读
2. 随机预读

预读可能会造成能降低buffer pool命中率的两种情况：

* 加载到buffer pool中的页不一定被用到
* 如果有非常多的使用频率偏低的页被同时加载到buffer pool中，则可能会把那些使用频率非常高的页从buffer pool中淘汰掉。

LRU链表优化：

1. 划分区域，young区域占5/8，old区域占3/8，用来解决预读问题
2. 优化young区域，头部1/4区域的节点不会变动，用于提高性能



可以设置多实例buffer pool来解决大量并发请求的情况。
