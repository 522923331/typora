我们知道，InnoDB是以页为单位来管理存储空间的。聚簇索引和辅助索引都是以B+树的形式保存到表空间中，而b+树的节点就是数据页。

表空间中的每一页都对应一个页号（fil_page_offset）,可以通过页号在表空间中快速定位到指定页面。页号由4个字节组成，也就是32位，所以一个表空间最多可以拥有2^32个页（42亿页）。一页16KB，那么一个表空间最多支持64TB的数据。

# 独立表空间结构

## 页、区、段、碎片段。

由于表空间的页可能会非常的多，为了更好的管理这些页面，InnoDB将每连续的64个页（64*16KB=1M）作为一个区，每256个区作为一个组。

在表中的数据量很大时，为某个索引分配空间的时候，为了消除随机I/O的可能，提高顺序I/O的可能，会按照区为单位进行分配。

同时，为了提高扫描记录的性能，InnoDB对B+树的叶子节点和非叶子节点进行了区分，也就说叶子节点有自己独有的分区，非叶子节点也有自己独有的分区。存放叶子节点的区的集合就算是一个段（segment），存放非叶子节点的区的集合也算是一个段（segment）。

也就是说一个索引会分成两个段：一个叶子节点端，一个非叶子节点段。

那么如果如上面所说，那么一个聚簇索引会生成两个段，一个段内至少申请一个区的存储空间，那么就是2M的存储空间。而有些表数据可能占用不了这么多的存储空间，如果这样开辟下去，对内存来说是极大的浪费。

基于上面的情况，InnoDB提出了碎片区（fragment）的概念，也就是在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，碎片区中的页可以用于不同的目的，比如有些页属于段 A. 有些页属于段 B.有 些页甚至不属于任何段.碎片区直属于表空间 并不属于任何一个段.（除了叶子节点段和非叶子节点段，InnoDB中还有为存储一些特殊的数据而定义的段，比如回滚段等）。

这样区就分成了4种不同的状态，InnoDB根据这4种状态来判断是否可以插入数据。

而对于free、free_frag和full_frag的数据，为了方便识别以及使用，InnoDB表空间对它们分别建立一个链表来管理，

而为了识别某个区是否属于哪个段，又为每个段（通过segmentID）分别维护3个链表，一个B+树有两个段，就是6个链表。

也就是说，一个普通的没有其它索引的表，会维护9个链表，每添加一个索引，就要多维护6个链表。

这样设计的初心仅仅是想减少随机I/O,而又不至于让数据量少的表浪费空间。

综上所述，表空间是由若干个区组成的 每个区都对应一个XDES Entry结构 ，直属于表空间的区对应的 XDES Entry 绪构可以分成 FREE,FREE_RAG,FULL_RAG 这3个链表.每个段可以拥有若干个区 ，每个段中的 区对应的 XDES Entry 结构可以构成 FREE，NOT FULL和FULL这3个链表.每个链表都对应一个 List Base Node 结构，这个结构中记录了链表的头尾节点的位置以及该链表中包含的节点数.正是因为这些链表的存在，管理这些区才变成了一件相当容易的事情.

# 系统表空间结构

系统表空间结构与独立表空间结构基本相似，只不过由于整个mysql进程只有一个系统表空间，系统表空间中需要记录一些与整个系统相关的信息，所以会比独立表空间多出一些用来记录这些信息的页面.因为这个系统表空间最重要，相当于所有表空间的 “带头大哥"，所以它的表空间ID(Space ID)是 0.

## INNODB数据字典

InnoDB中有一些系统表，这些系统表就被称为数据字典。他们是以B+树的形式保存在系统表空间的某些页面中，其中 SYS_TABLES SYS_COLUMNS ,SYS_INDEXES ,SYS_FIELDS 这4个表尤其重要，称为基本系统表 (basic system table)。

### information_schema系统数据库

需要注意的一点是，用户不自直接访问 InnoDB 这些 内部系统表， 除非直接去解析系统表空间对应的文件系统上的文件。不过设计 InnoDB的大叔考虑到 查看这些表的内容可能有助于大家分析问题，所以在系统数据库 information_ schema中提供了一些以INNODB_SYS开头的表，这些以INNODB_SYS开头的表并不是真正的内部系统表，而是在存储引擎启动时读取这些以SYS 开头的系统表，然后填充到这些以 INNODB_SYS开头的表中。 以INNODB_SYS开头的表和以 SYS 开头的表中的字段并不完全一样，但是供大家参考足矣。

# 总结

设计InnoDB 的大叔出于不同的目的而设计了不同类型的页面。这些不同类型的页面基本都有 File Heade File Trailer 的通用结构。

表空间被划分为许多连续的区，对于大小为 16KB 的页面来说，每个区默认自由64 个页〈也就是 1MB) 组成，每 256 区( 也就是 256MB)划分为一组，每个组最开始的几个页面的类型是固定的。

段是一个逻辑上的概念，是某些零散的页面以及一些完整的区的集合。	

每个区都对应一个 XDES Entry 结构，这个结构中存储了一些与这个区有关的属性.这些区可以被分为下面几种类型。

* 空闲的区：这些区会被加入到 FREE 链表.

* 有剩余空闲页面的碎片区：这些区会被加入到 FREE_FRAG 链表。

* 没有剩余空闲页面的碎片区：这些区会被加入到 FULL_FRAG 链表。

* 附属于某个段的区：每个段所属的区又会被组织成下面几种链表：
  * FREE 链表:在同一个段中，所有页面都是空闲页面的区对应的 XDES Entry 结构会被加入到这个链表。
  * NOT_FULL 链表:在同一个段中，仍有空闲页面的区对应 XDES Entry 结构会被加入到这个链表。
  * FULL 链表·在同一个段中，已经没有空闲页面的区对应的 XDES Entry 结构会被加入到这个链表。

每个段都会对应一个因INODE Entry 结构，该结构中存储了一些与这个段有关的属性。

表空间中第一个页面的类型为 FSP_HDR 它存储了表空间的一些整体属性以及第一个组内256 个区对应的 XDES Entry 结构。

除了表空间的第一个组以外，其余组的第一个页面的类型为 XDES ，这种页面的 结构和FSP_HDR 类型的页面对比，除了少了 File Space Header 部分之外(也就是除了少了记录表空间整体属性的部分之外) ，其余部分是一样的。

每个组的第二个页面的类型为 IBUF_BITMAP ，存储了一些关于 Change Buffer的信息。

表空间中第一个分组的第三个页面的类型是时INODE ，它是为了存储剧INODE Entry 结构而设计的，这种类型的页面会组织成下面两个链表：

* SEG_INODES_FULL 链表：在该链表中，INODE 类型的页面中己经没有空闲空间来存储额外的INODE Entry 结构。
* SEG_INODES_FREE 链表：在该链表中，INODE 类型的页面中还有空闲空间来存储额外的INODE Entry 结构。

Segment Header 结构占用 10 字节，是为了定位到具体的INODE Entry 结构而设计的。

与独立表空间相比，系统表空间有一个非常明显的不同之处 ，就是在表空间开头有许多记录整个系统属性的页面。

InnoDB 提供了一系列系统表来描述元数据，其中 SYS_TABLES、SYS_COLUMNS、 SYS_INDEXES、SYS_FIELDS 这4个表尤其重要，称为基本系统表 (basic system table ). 系统表空间的第7个页面记录了数据字典的头部信息。
