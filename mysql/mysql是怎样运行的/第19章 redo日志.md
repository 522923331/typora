# redo日志是啥

当修改表数据后，其实是修改的buffer pool内存中的缓冲页的数据，那么如果数据尚未刷盘成功，系统故障导致内存中的数据都失效了，那么正常情况下，数据就是丢失了，这是我们所不能接收的。

那么一个简单的处理方式就是在事务完成之前，把该事务修改的所有页数据刷盘。不过这个简单粗暴的做法存在下面两个问题：

* 刷新一个完整的数据页太浪费了。我们可能只是修改了某个页面中的一个字节，但是InnoDB是以页为单位来进行磁盘I/O。因为改了一个字节就要刷新16KB的数据到磁盘上，显然太浪费了。
* 随机I/O刷新起来比较慢。一个事务可能包含很多语句，每条语句修改的数据的页面可能并不相邻。页面刷盘就变成了随机I/O,随机I/O比顺序I/O要慢。

那么解决方案就是引入redo log（重做日志）。我们的目的是让修改后的数据永久生效，即便系统崩溃后也能通过重启后根据redo log来重新更新一下数据页，来满足持久性。

只将该事务执行过程中产生的redo  log 刷新磁盘的好处: 

* redo log只记录修改的内容，日志占用空间很小。只存储了表空间ID、页号、偏移量以及更新值。
* redo log日志是顺序写入磁盘的：在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序I/O。

# redo日志的写入过程

前面说过，mysql为了解决磁盘速度过慢的问题而引入了buffer pool。同理，写入redo log日志时也不能直接写到磁盘，而是先写到redo log buffer（redo日志缓冲区），这是一块连续的内存空间，也可以将其简称为log buffer，默认大小为16MB，这片内存空间被划分为若干个连续的redo log block（block和页是一个意思，也就是分成了多个页），每个block大小为512字节。

向log buffer 中写入redo日志的过程是顺序写入的。



redo log buffer有一个全局变量buf_next_to_write，用来标记当前log buffer中已经有哪些日志被刷新到磁盘中了。

全局变量log sequence number（lsn）表示当前系统中写入redo日志量，包括写到redo log buffer但没有刷新到磁盘的redo日志。

redo log有个全局变量flushed_to_disk_lsn，表示刷新到磁盘中的redo日志量。

综上所述，当有新的redo日志写入到log buffer时，首先lsn的值会增长，但是flushed_to_disk_lsn不变；随后随着不断有log buffer中的日志被刷新到磁盘上，flushed_to_disk_lsn的值也跟着增长。当两者相同时，说明log buffer中的所有日志都已经刷新到磁盘了。

## redo日志刷盘时机

redo 日志会先存放在redo log buffer中，在下面的情况下，它们会被刷新到磁盘中：

* redo log buffer 空间占用超过50%时，就会把这些日志刷新到磁盘

* 事务提交时

  前面说过，引入redo log主要是为了防止系统崩溃后，无法恢复数据，还是有就是它占用的空间很小。事务提交的时候，可以不把修改过的buffer pool页面立即刷新到磁盘，但是为了保证持久性，必须要把页面修改时所对应的redo日志刷新到磁盘

* 后台线程，每秒一次的频率将log buffer中的redo日志刷新到磁盘

* 正常关闭服务器时

* 做checkpoint时

redo log日志文件默认大小是48MB，日志文件最多是100个，超过100个日志能存放的量，会循环从第一个日志文件开始记录。

那么岂不是要“追尾”？于是mysql就提出了checkpoint的概念。

## redo日志的刷盘配置

为了保证事务的持久性，用户线程在事务提交时需要将该事务执行过程中产生的所有redo日志都刷新到磁盘中。这一条要求太狠了，会明显降低数据库性能。如果对持久性要求不那么强烈，那么可以通过修改系统变量值：

有三种配置：

* 0：当系统变量为0时，表示在事务提交时不立即向磁盘同步redo日志，这个任务交给后台线程来处理；这样会明显加快请求处理速度。但是，如果事务提交后服务器挂了，会有1秒的数据丢失。
* 1：默认值，表示在事务提交时需要将redo日志同步到磁盘，可以保证事务的持久性。
* 2：表示在事务提交时，需要将redo日志写到操作系统的缓冲区，但并不需要保证将日志真正的刷新到磁盘。如果数据库挂了，操作系统没挂，事务的持久性还是可以保证的。但如果操作系统也挂了，无法保证持久性。

# checkpoint

redo日志是为了在系统崩溃后恢复脏页用的，如果脏页已经刷盘，那么该redo 日志 也就没有存在的必要了，它所占用的磁盘空间就可以被后续的redo 日志所重用。

InnoDB提出了一个全局变量checkpoint_lsn，用来表示当前系统中可以被覆盖的redo日志总量是多少。

比如页a被刷新到磁盘，就可以进行增加checkpoint_lsn的操作，我们把这个过程称为执行一次checkpoint。

换句话说，执行一次checkpoint的意思就是增加checkpoint_lsn的值。

注意：将“脏页刷新到磁盘”和“执行一次checkpoint”是两回事，它们是在不同的线程上执行的。

例子：我们知道每个页会有：最小修改值（oldest_modification）和最大修改值（newest_modification）

比如页a刷盘了，页b是flush链表的尾结点，那么页b的最小修改值就会赋值给checkpoint_lsn。也就是说，小于页b的最小修改值的内存，都可以被覆盖。

# 崩溃恢复

## 确定恢复的起点

起点就是checkpoint_lsn值，大于这个值的脏页有可能刷盘了，也有可能没有刷盘（因为是分别两个线程，异步处理的），不能确定，那就从checkpoint_lsn值开始。根据这个值，就可以找到对应redo日志的偏移量。

## 确定恢复的终点

终点就在redo log buffer 的block中，对于被填满的block来说，该值永远为512。那么小于512的那个block就是终点。

## 怎么恢复

恢复优化方案：

* 使用哈希表

  把表空间ID和页号相同的redo 日志放到哈希表的同一个槽中，如果有多个表空间ID和页号相同的redo日志，那么就使用链表连接起来（按照生成的先后顺序）。之后就可以遍历哈希表。因为对同一个页面进行修改的redo日志都放在了一个槽中，所以可以一次性将一个页面修复好（避免了很多读取页面的随机I/O）,这样可以加快恢复速度。

* 跳过已经刷新到磁盘中的页面

  因为大于checkpoint_lsn的脏页也有可能已经被刷新到磁盘，所以恢复数据时也就没有必要再处理一次了。

  File Header中有个FIL_PAGE_LSN属性，该属性记录最后一次修改页面时对应的lsn的值，如果它大于等于本页的最大修改值（newest_modification），那么就不需要恢复了，所以进一步提升了崩溃恢复速度。



# 总结

以上

